\documentclass[11pt]{article}

% Use wide margins, but not quite so wide as fullpage.sty
\marginparwidth 0.5in 
\oddsidemargin 0.25in 
\evensidemargin 0.25in 
\marginparsep 0.25in
\topmargin 0.25in 
\textwidth 6in \textheight 8 in
% That's about enough definitions


\begin{document}
\hfill\vbox{\hbox{Shin, Jude}
		\hbox{CSC 453, Section 01}	
		\hbox{Lab 04}	
		\hbox{\today}}\par

\bigskip
\centerline{\Large\bf Lab 4: {\sc Minix} Scavenger Hunt, Part II}\par
\bigskip

This lab is meant to demonstrate an understanding of installing a {\sc Minix} system on a Virtual Machine. We also dive deeper into the kernel code by slightly modifying the IDLE process. I installed {\sc Minix 3.1.8} on Oracle's {\sc VirtualBox Manager}. The host machine (my laptop) is running vanilla {\sc Arch Linux}.

\setcounter{section}{0}
\section{Before I do (mess up) anything}
I made a .tar of the entire {\sc Minix} folder that held the kernel so if I screwed something up, I could just delete the folder and {\tt untar} the backup.

\section{Build a modified kernel}
\subsection{Approach}
I first looked in the textbook for {\sc Minix}s queues. When there is nothing to do, then the last {\tt IDLE} queue is what is run constantly. I am going to try and toss in that if statement somewhere in place of that {\tt IDLE} function to alter it's functionality. When I found the place that described the {\tt IDLE} queue, said that there was a reference to it in {\tt kernel/proc.c}. I used {\tt vi} to inspect that file, and found a well commented part of the code which defined a function {\tt PRIVATE void idle(void)}. 
I just modified the function to look like the following code, just adding the given {\tt if-statement} to the beginning of the function.

Then {\tt make hdboot} would make a new image, at which point I copied the image to the {\tt /boot/image} directory with the command {\tt cp /usr/src/tools/image /boot/image}.

\begin{verbatim}
PRIVATE void idle(void) {
	/* ...my comments... */
	if (TRUE) {
		printf("@\b");
	}

	/* ...comments... */
	context_stop(proc_addr(KERNEL));
	halt_cpu();

	/* ...comments... */
}
\end{verbatim}

\subsection{Problems Encountered}
The only thing that was hard to use was the tiny screen that was only black and white. I am used to my fancy terminal emulators on my {\sc linux} machine, so tools like {\tt grep} and {\tt vim} have a bunch of fancy colors. I also have a lot of keybinds in {\tt vim} for my machine and I kept forgetting that the keybinds are very different.

\subsection{Solutions}
Nothing special had to happen in order for me to use these tools. I just had to get used to them. For grep, I had to remember to explicitly search in the current directory ({\tt ./}), and for vi I had to use the actual {\tt esc} button instead of the remap of {\tt kj}. I also had to be sure that the file I wrote didn't have any extra characters from the terminal not updating. 

\subsection{Lessons Learned}
The main bulk of the code seems to be located in the {\tt /usr/src/kernel} directory. I liked all of the comments that were there to help with finding things with keywords. 

\section{Test it}
\subsection{Approach}
\subsubsection{Login Test}
When logging in, there were some bits of text that would have the ``@" symbol after it, and some that would not. I believe that the times when the kernel was setting up some important things (like the daemon or services), the ``@" wasn't printed. Then when the kernel was just waiting for the input (like keystrokes for logging me in), the ``@" symbol was printed, as the kernel had nothing else to do. Below is the output of a sample run. Note the ``@" symbol on the line that states the {\tt Multiuser startup in progress ...@} and on the login line. The lines between seem to be kernel level tasks like starting the daemons. Those are kernel level tasks that probably has some priority in a different queue (not idle). However, when waiting for an input from an I/O bound process (like the keybaord for logging in), then the kernel waits idle, and prints the ``@'' as a result. 

\begin{verbatim}
Root device name is /dev/c0d0p0s0
Multiuser startup in prgress ...@
Sat Nov  1 20:49:08 GMT 2025
/dev/c0d0p0s2 is read-write mounted on /usr
/dev/c0d0p0s1 is read-write mounted on /home
Starting services: random inet printer ipc.
Starting daemons: update corn syslogd.
Starting netowrking: nonamed.
Local packages (start): sshd Starting sshd.
 done.
@
Minix Release 3 Version 1.8  (console)

10.0.0.1 login: @
\end{verbatim}

\subsubsection{Fork Bomb Test}
Another test I did was write a little fork bomb which just created a bunch of children who printed a message. When the fork system call is performed, the privilege is given to the kernel through an interrupt. The kernel now has something to do. During the time it takes for the kernel to handle the interrupt, the ``@" symbol does not show at the end of the print statements. Below is the small c file that I compiled and ran. Something is running through this entire process, so there should be no ``@" symbols in the entire output.

\begin{verbatim}
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

#define NUM_FORKS 100000

int main(int argc, char *argv[]) {
  int i, j;
  pid_t pids[NUM_FORKS];
  pid_t pid;
  
  /* Create a bunch of dumb children */
  for (i=0; i<NUM_FORKS; i++) {
    printf("Forking Child %d\n", i);
    pid = fork();
    if (pid < 0) {
      perror("[main] error creating child");

      /* clean up all of the forks that were previously created */
      for (j=0; j < i; j++) {
        waitpid(pids[j], NULL, 0);
      }
      exit(EXIT_FAILURE);
    }
    else if (pid == 0) {
      /* Child Code */
      printf("Child %d created!\n", i);
      /* sleep(1); */
      exit(EXIT_SUCCESS);
    }
    else {
      /* Parent Code */
      /* add the pid to the list of pids */
      pids[i] = pid;
    }
  }

  for (i=0; i<NUM_FORKS; i++) {
    printf("Waiting for child %d...\n", i);
    waitpid(pids[i], NULL, 0);
  }

  exit(EXIT_SUCCESS);
}
\end{verbatim}

Here is some sample output of when this code is run. Note that there are no ``@" symbols present.

\begin{verbatim}
Forking Child 0
Forking Child 1
Child 0 created!
Forking Child 2
Child 1 created!
Forking Child 3
Child 2 created!
Forking Child 4
Child 3 created!
Waiting for child 53580...
Child 4 created!
Waiting for child 53580...
Waiting for child 53580...
Waiting for child 53580...
Waiting for child 53580...
$ @
\end{verbatim}

\subsubsection{Simple While Loop}
A more simple solution would be to write a program that just chases its tail. During this process, the ``@" symbol should not be printed.

\begin{verbatim}
int main(int argc, char *argv[]) {
	printf("starting infinite loop\n");
	while (1) {
		/* foo */
	}
	exit(EXIT_SUCCESS);
}
\end{verbatim}

Here is some sample output of when this code is run. Note that there are no ``@" symbols present. Only when the process is killed by the {\tt ctrl-C} interrupt does the ``@" symbol undo itself.

\begin{verbatim}
$ ./while@
starting infinite loop
^C
$ @
\end{verbatim}

\subsection{Problems Encountered}
I didn't know what it meant by ``the kernel has nothing to do". I am assuming that I had to make the kernel do something long while printing to prove that the cursor didn't get displayed for a period of time. 

\subsection{Solutions}
For some reason I did not understand that if a process is running, then the system is running, therefore, the process is not idle (crazy, I know...). This includes both kernel level commands, as well as user level commands. 

\subsection{Lessons Learned}
The user level processes are also included in the umbrella term of "not idle". Kernel level tasks will trump those processes, but it is a process nonetheless. The idle while loop is a testament to this (as well as the fork\_bomb script). Something is running, so the system is not idle; therefore, the ``@" symbol is not printed. It is as simple as that. 

\end{document}
